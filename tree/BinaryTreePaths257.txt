
public class TreeNode {
     int val;
     String path;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }
//给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
//通过void函数可以从root开始实现从头到尾顺序的递归
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new ArrayList<>();
        findPath(list,"", root);
        return list;
    }
    public void findPath(List<String> list, String path, TreeNode root){
        StringBuffer newPath = new StringBuffer(path);
        newPath.append(Integer.toString(root.val));
        if(root.left == null && root.right == null){

            list.add(newPath.toString());
        }else{
            newPath.append("->");
            if(root.left != null){
                
                findPath(list, newPath.toString(), root.left);
            }
            if(root.right != null){
                findPath(list, newPath.toString(), root.right);
            }
        }
    
    }
    
}